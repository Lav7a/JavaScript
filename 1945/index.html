<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>1945 - Mini JS Shooter (Very Easy Mode)</title>
  <style>
    html,body{height:100%;margin:0;background:#111;color:#eee;display:flex;align-items:center;justify-content:center;font-family:Inter,Arial}
    #gameCanvas{background:linear-gradient(#001020,#002040);display:block;border:6px solid #222;border-radius:8px}
    .ui{position:fixed;left:20px;top:20px;color:#fff;opacity:.95}
    .hint{position:fixed;right:20px;top:20px;color:#ddd;font-size:14px;max-width:260px;text-align:right}
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="360" height="640"></canvas>
  <div class="ui">Score: <span id="score">0</span> &nbsp; Lives: <span id="lives">3</span></div>
  <div class="hint">← → 이동, 스페이스: 발사, P: 일시정지</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

let keys = {};
addEventListener('keydown', e=>{ keys[e.code]=true; if(e.code==='Space') e.preventDefault(); });
addEventListener('keyup', e=>{ keys[e.code]=false; });

let running = true;
let paused = false;
let score = 0;
let lives = 3;

const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');

const player = { x: W/2, y: H-70, w: 28, h: 36, speed: 3.8, cooldown:0,
  draw(){ ctx.save(); ctx.translate(this.x,this.y);
    ctx.fillStyle='#cfc';
    ctx.beginPath(); ctx.moveTo(0,-16); ctx.lineTo(12,10); ctx.lineTo(6,10);
    ctx.lineTo(6,18); ctx.lineTo(-6,18); ctx.lineTo(-6,10); ctx.lineTo(-12,10);
    ctx.closePath(); ctx.fill();
    ctx.fillStyle='#3b6'; ctx.fillRect(-5,-12,10,8); ctx.restore(); }
};

let bullets = [];
function spawnBullet(x,y,dx=0,dy=-7,friendly=true,damage=1,r=4){ bullets.push({x,y,dx,dy,r,friendly,damage}); }

let enemies = [];
function spawnEnemy(type=1){
  const ex = Math.random()*(W-50)+25;
  const ey = -30;
  const hp = type===1?2:5;
  const speed = type===1?1.2:0.6;
  enemies.push({x:ex,y:ey,w:30,h:22,dx:0,dy:speed,hp,type,shootCooldown:60+Math.random()*120});
}

let particles = [];
function explode(x,y,color,amount=18){ for(let i=0;i<amount;i++){
  particles.push({x,y,dx:(Math.random()-0.5)*4,dy:(Math.random()-0.5)*4,life:30+Math.random()*30,color});
}}

let frame=0, spawnTimer=0, enemyWave=0;

function update(){
  if(!running||paused) return;
  frame++;

  if(keys['ArrowLeft']||keys['KeyA']) player.x-=player.speed;
  if(keys['ArrowRight']||keys['KeyD']) player.x+=player.speed;
  player.x=Math.max(14,Math.min(W-14,player.x));

  if(player.cooldown>0) player.cooldown--;
  if(keys['Space'] && player.cooldown===0){
    spawnBullet(player.x,player.y-18,-0,-8);
    player.cooldown=8;
  }

  for(let i=bullets.length-1;i>=0;i--){
    const b=bullets[i]; b.x+=b.dx;b.y+=b.dy;
    if(b.y<-20||b.y>H+20) bullets.splice(i,1);
  }

  spawnTimer--;
  if(spawnTimer<=0){
    enemyWave++;
    const count=1; // 한 번에 한 마리만 스폰
    for(let i=0;i<count;i++) spawnEnemy(Math.random()<0.85?1:2);
    spawnTimer=50; // 스폰 간격 길게
  }

  for(let i=enemies.length-1;i>=0;i--){
    const e=enemies[i]; if(e.type===1) e.x+=Math.sin((frame+e.x)/40)*0.8; e.y+=e.dy;
    e.shootCooldown--; if(e.shootCooldown<=0){
      bullets.push({x:e.x-6,y:e.y+12,dx:0,dy:3.4,r:4,friendly:false});
      if(Math.random()<0.4) bullets.push({x:e.x+6,y:e.y+12,dx:0,dy:3.8,r:4,friendly:false});
      e.shootCooldown=80+Math.random()*120;
    }
    if(e.y>H+40) enemies.splice(i,1);
  }

  for(let i=enemies.length-1;i>=0;i--){
    const e=enemies[i];
    for(let j=bullets.length-1;j>=0;j--){
      const b=bullets[j]; if(!b.friendly) continue;
      if(Math.hypot(b.x-e.x,b.y-e.y)<20){ e.hp-=1; bullets.splice(j,1);
        if(e.hp<=0){ explode(e.x,e.y,'orange'); score+=e.type===1?100:350; enemies.splice(i,1); break; }
      }
    }
  }

  for(let i=bullets.length-1;i>=0;i--){
    const b=bullets[i]; if(b.friendly) continue;
    if(Math.hypot(b.x-player.x,b.y-player.y)<18){ bullets.splice(i,1); hitPlayer(); }
  }

  for(let i=enemies.length-1;i>=0;i--){
    const e=enemies[i]; if(Math.hypot(e.x-player.x,e.y-player.y)<22){ explode(e.x,e.y,'red'); enemies.splice(i,1); hitPlayer(); }
  }

  for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.x+=p.dx;p.y+=p.dy;p.life-=1; if(p.life<=0) particles.splice(i,1); }

  scoreEl.textContent=score; livesEl.textContent=lives;
}

function hitPlayer(){ explode(player.x,player.y,'white'); lives-=1; if(lives<=0){ running=false; setTimeout(()=>{ alert('Game Over! Score:'+score); resetGame(); },40); }else{ player.x=W/2; player.y=H-70;} }

function resetGame(){ enemies=[]; bullets=[]; particles=[]; score=0; lives=3; running=true; spawnTimer=60; enemyWave=0; }

function draw(){
  ctx.clearRect(0,0,W,H);
  for(let s of starSeed){ s.y+=0.4; if(s.y>H) s.y=-2; ctx.beginPath(); ctx.fillStyle='rgba(255,255,255,'+(0.2+s.s*0.3)+')'; ctx.arc(s.x,s.y,s.s,0,Math.PI*2); ctx.fill(); }
  for(const e of enemies){ ctx.save(); ctx.translate(e.x,e.y);
    if(e.type===1){ ctx.fillStyle='#f88'; ctx.beginPath(); ctx.ellipse(0,0,14,10,0,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#a33'; ctx.fillRect(-8,-8,4,4); }else{ ctx.fillStyle='#f5d'; ctx.fillRect(-18,-10,36,20); ctx.fillStyle='#a05'; ctx.fillRect(-10,-6,6,12); ctx.fillRect(4,-6,6,12); }
    ctx.restore(); }
  for(const b of bullets){ ctx.beginPath(); ctx.fillStyle=b.friendly?'#ffd':'#f44'; ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); }
  player.draw();
  for(const p of particles){ ctx.globalAlpha=Math.max(0,p.life/40); ctx.fillStyle=p.color||'orange'; ctx.fillRect(p.x,p.y,2,2); } ctx.globalAlpha=1;
}

let starSeed=[]; for(let i=0;i<60;i++) starSeed.push({x:Math.random()*W,y:Math.random()*H/1.5,s:Math.random()*1.6});

function loop(){ update(); draw(); requestAnimationFrame(loop); }
addEventListener('keypress', e=>{ if(e.code==='KeyP') paused=!paused; });
spawnTimer=40; resetGame(); loop();
</script>
</body>
</html>
